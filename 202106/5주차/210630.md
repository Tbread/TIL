모든 예외는 Throwable임 (집합생각하면됨)
근데 이제 크게 두가지로 갈리는데
Error와 Exception으로 나뉨
Error는 심각한 시스템 수준의 에러
(여기서 01자료 보여줌)
Exception은 또 두개로나뉨
Checked Exception과 Runtime Exception

Checked Exception은 컴파일러가 알려줄수있는 에러
(02자료보여주면서)
해당 코드는 파일을 읽어오는건데
이 파일이 없을수도있으니 예외처리를 해줘야함
근데 예외처리를 안했으니까 컴파일러가 알려줌 이런게 예외처리

Runtime Exception은 Chked Exception의 반대로 Unchecked Exception이라고 하며
컴파일러가 인식을 할수가없음
이거는 실행중에만 발생하며 개발자가 '아 이런 경우가 있을수도있을거같은데? 예외처리해두자'
하지않으면 발생함
(03자료보여줌)
코드자체는 a를 b로 나눈걸 출력하라는 평범한 코드이지만
실행시켜보면 b는 0이고 0으로나누라고하니까 에러가남

chk랑 unchk의 차이점은 반드시 처리를 해줘야하느냐 의 차이점이다

어쨌든 unchk는 실행은 가능하니까..
예를들어서 아까 03에서 a 나누기 b에서 b를 사용자에게 입력받을수도있는데
사용자가 0을 입력할수도있으니 그야말로 컴파일러는 체크할수가없다
하지만 02자료에서는 파일이 있을수도있고 없을수도있는 딱 두가지상황뿐이니
컴파일러가 야 없을수도있으니까 무조건 예외처리해놔! 라고 말할수있는것
(02의 주석처리를 풀고 컴파일하면 계속 2번이 걸리는걸 보여줌)

예외를 처리해주어야하는이유
예를 들어서 은행같은경우
은행에서 계좌번호를 입력하는데
계좌번호가 올바르지않을경우의 예외처리를 해주지않으면
누군가가 atm에서 번호를 잘못누르는순간 프로그램이 뻗어버릴테니 은행입장에서는 상당히 곤란해진다
이를 대비하여 입력받은번호 != db안의계좌번호 일경우의 예외처리로 올바르지않은계좌번호입니다!
를 띄워주고 처음으로 돌아간다면 불상사를 방지할수있다

일단 예외처리코드는 보통 try와 catch를 사용한다
일단 코드 try를 실행시도하고 에러가 발생시 catch로 특정에러가 떴을경우에 해당 코드를 실행한다
(자료 04_00_trycatch)
또 finally는 에러가 날수도있지만 에러가 나던 안나던간에 반드시 실행시켜야하는 코드가 존재할수있다
(자료 04_00_trycatch_finally)
해당경우에는 finally를 사용하는데 이를 사용하면 try에 성공했던 하지못했던
마지막에 반드시 finally안의 코드를 실행한다



그리고 이런 예외들을 처리하는방법에는 크게 세종류가있다
예외 복구,예외처리회피,예외전환 세종류가있는데
예외복구부터 살펴보겠다
(04_01 자료 보여줌)
파일다운로드 시도를 하고 서버연결이 안되면 다시 올라가서 재시도하는형태
이게 예외복구

예외처리회피의 경우에는
(자료 04_02)
아까 봤던것처럼 try catch처럼 사전에 알수있는경우에
이런오류의 경우에는 그냥 넘어가서 이거 실행해라 처럼 하는경우나
(자료 04_02주석처리부분)
처럼 if로 사전에 이런경우에는 이렇게 해라 라고 하는걸 말한다
다만 예외처리회피는 신중하게 해야하는데
예를들어서 크기가 5인 배열 arr이 있고
사용자가 이배열어딘가의 인덱스를 input에 넣어 호출하려고한다(arr[input])
만약 이때 사용자가 5를 입력했다면 arr[5]인데 배열은 arr[4]가 마지막값이기때문에
OutOfIndex에러가 날것이다
그렇기에 개발자는 사용자가 배열의 마지막인덱스값을 넘어선 input을 입력하려할경우에는
마지막 인덱스를 호출하려고한다
그러면 개발자는 if input <= arr.size - 1일때 arr[input-1]을 사용할수도있지만
input이 6일경우에는 다시 에러를 뿜을수도 있고
다른 코드로인해 arr에 값이 추가되어 배열이크기가 6이되었다면 arr[5]를 호출해야함에도
arr[4]를 호출하게 될것이다
그러니 arr[arr.size()-1]같은 최선의코드라고 확신할수 있을때만 예외처리회피를 사용하여야한다

예외전환

정확히 어느부분에서 예외가 발생했는지 알기위해 사용한다
(자료 04_03)
해당 클래스를 실행하면 0으로 나눴기에 ArithmeticException이 뜬다
현재는 나누는자료가 한개밖에 없기에 바로찾을수있지만
코드가 길어질경우 나누는 코드들이 여러개생길수도있고
이경우에는 받은 매개변수값이 0이기에 나누다가 에러가생겼을수도있고
다른부분에서 0으로 나누는걸 입력해놔서 에러가 생겼을수도있다
(주석처리해제)
이럴경우 이처럼 호출받은 메소드에서 예외처리를 throw해서
'너의 매개변수값이 0이기에 오류가 0으로 나누는 오류가 난거야!'
라고 말해주기위해 IllegalArgumentException으로 예외를처리해줄수있다


오늘 예외처리를 공부하면서 느낀점은 코드가 안된다고 무턱대고 try catch를 쓸게아니라
어째서 안됐는지를 파악하고 (왜 이러는지를 알아야 어떻게 처리를할지 생각할수있으므로)
어느경우에 어떻게 처리해야하는지를 고민을 많이 해봐야할것같다
또 어떻게 사용자는 정말 상상도 하지못할 많은방법으로 프로그램을 사용할수있다
ex)int형의 자료를 달라니까 소수를 주기..문자열을주기..int의 최대값을 넘는 범위의 정수를 보내기..등등
이런 사용자의 잘못된 입력이 어떻게 들어올수있는지에 대해서도 정말 많이 떠올려봐야 할것같다


오늘 발표자료를 위해 두서없이 써내려갔던 텍스트파일...
무슨소린지 모르겠을떈 오늘 정리한
https://tbread-development.tistory.com/14 을 한번더 


------------------

static 메소드 에서는 static변수만 사용하고 다른 지역변수를 사용하지않는다

static 변수는 해당 변수를 포함한 메소드가 로드되는순간 메모리에 저장된다(잘이해못함)

final 클래스는 extentds 될수없음

final 메소드에는 @overriding이 불가능함

final 멤버변수or지역변수에는 값을 변경할수없다

abstract 클래스는 클래스내에 추상메서드가 포함됨을 의미

abstract 메서드는 선언부만있고 구현부는 존재하지않는 메서드(추상메서드)를 의미함
function(){}에서 {}부분
*미완성메소드라고 하기도한다


접근제어자

private -> 같은 클래스내에서만 접근이 가능

default -> 같은패키지내에서만 접근가능(생략가능)

protected ->같은패키지내의 다른패키지의 자손클래스에서 접근가능

public -> 접근제한이 아예없음

클래스앞에는 default와 public만 사용가능
멤버변수앞에는 모두사용가능





디자인패턴

디자인패턴의 구조

콘텍스트
문제가 발생하는 상황자체
또는 패턴이 유용하지못한 상황

문제
패턴이 적용되어 패결될필요가있는 디자인이슈

해결
문제를 해결하도록 요소를 구성




패턴의 분류

생성패턴
객체의 생성과조합을 캡슐화해 객체를 생성하거나 변경해도 영향을 크게받지않도록 유연성을 제공(Dto등)

구조패턴
서로다른 2개의 객체를 묶어서 한개의 인터페이스를 제공하거나 새로운기능을 제공

구조패턴안의 어댑터
한클래스의 인터페이스를 클라이언트에서 사용하기위해 다른엔터페이스로 변환시켜줌
**예를들어 A에선 123의문자열을 사용하는데 b에선 123의 int가 필요하다면 123의문자열을 123의 int로 바꿔주는걸 말하는것같음
사용하는 이유 -> 기존코드를 다른 곳에서 다른 형식으로 사용하면서도 변경시키지않기위해
단점 -> 클래스가 많아지면서 복잡해질수있고,유연성이 떨어지게됨



싱글턴패턴
전역변수를 사용하지않고 객체를 하나만 생성하여 생성된 객체를 어디서든지 참조할수있도록 하는패턴
잘모르겠음..포인터개념?

장점->메모리낭비 방지가능,데이터의 공유가 쉬움
단점->많이쓰면 결합도가 떨어짐 (객체지향에서 멀어지게됨),수정과 테스트가 어려움

싱글턴패턴을 쓰는이유를 조금더 찾아보면좋을것같음

은행개념으로 생각하니 조금 이해가 됐음
만약 A계좌에서 B계좌로 5000원을 송금한다면 A계좌잔액 - 5000과 B계좌잔액 +5000을 일일히 해주는것이아니라
5000이란값을 싱글턴에넣고 A에선 빼고 B에선 더하는 그러니까 5000이라는 변수가 두개있을필요가 없다는 느낌?


