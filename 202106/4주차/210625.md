자바 변수선언시 -> 항상 자료형을 변수명앞에 붙여줘야함 (List,int,string등등)

배열 선언방법 -> List<배열에담을자료형> 배열명 = new ArrayList<>()

자바의 메소드 -> 타언어의 함수선언과 비슷한듯? 메인함수 진입전에 써두는것같음
추가한 메소드를 메인함수내에서 사용하려면 메소드 선언시 static을 추가해 주어야함

자바 반복문은 자바스크립트와 같음 (다만 let 대신 int같은 자료형을 붙여줌)

배열.get (인덱스) -> 해당배열인덱스위치의 값을 가져옴

배열.size() - > 배열의 크기를 가져옴(파이썬의 len)

자바는 null문자열을 그대로 null로 표기함(파이썬의 None)

클래스의사용 -> 클래스파일명 변수명 = new 클래스파일명() ----> 필요하다면 클래스파일명(파라미터)로 사용할것으로 예상됨
이전에 오토핫키에서 사용할때 다른파일에서 함수끌어와 사용하는거랑 비슷한듯?
클래스에서의 기본생성자 -> 변수선언의 클래스버전같다 int var1 처럼 public course 라던가..
다만 뒤에 파라미터값을 전달받는부분에선 함수와 비슷하다고 생각하면될듯

this - > 내가 호출됐을때 현재 나에게 전달받은값?또는 나 자체? 이해는 했는데 글로 풀어설명하기가어렵다
클래스에서 특정변수를 private로 선언했을경우 해당  변수값은 같은 클래스내에서 설정한 메소드를 이용해야만 변경이 가능함 (보통 해당 메소드의 이름은 set바꿀변수이름 으로 정해진다

외부에서 해당 메소드 호출방법 -> 클래스사용선언했을때 사용한 변수명.변경을위해만든메소드명(파라미터)

private선언시 변수변경뿐만아니라 조회또한 메소드를 추가로 만들어줘야함 -> set처럼 이름을 get변수명으로 메소드를 만든뒤 return this.변수명같은 형식을 사용하여 반환을 받으면됨
추측)this로 같은 클래스내의 다른메소드로 가져온 변수는 서로다른변수로 취급되나?

클래스를 서버응답용으로 만드려면 @RestController를 클래스선언전에 입력 파이썬의 플라스크와 비슷해보임

gradle -> 프로젝트에 사용한 라이브러리를 모아서정리해두는?느낌 html에서 부트스트랩을 사용할때 스크립트로 해당 부트스트랩의 링크를 가져오는데 gradle은 그 링크들을 모아두는 서식?이라고 보면될것같다

H2 -> ram마냥 서버가 꺼지는순간 db가 삭제됨,휘발성db

클래스에서의 @Entity -> 해당클래스는 테이블로써 사용됨을 선언

@NoArgsConstructor -> 파라미터가 없을때 기본생성자를 자동생성하기위한 선언문

extends -> 어떻게 사용하는지는 이해했으나 개념적으로 잘 모르겠음 특정 클래스를 extend로 가져오면 가져온 해당 클래스의 변수와 메소드를 별도의 처리없이 바로 가져다 쓸수있다는것같은데 함수와 다른점은 뭐지?

LocalDateTime -> 파이썬의 Datetime같은 시간형 변수 (int,string같은)

abstract 선언 -> 해당 클래스는 상속으로만 사용가능함 (독립적으로 사용불가능)
